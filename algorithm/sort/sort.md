# 排序

## 冒泡排序

循环数组，比较当前元素和下一个元素，如果当前元素比下一个元素大，向上冒泡。下一次循环继续上面的操作。

优化：当一次循环没有发生冒泡，说明已经排序完成，停止循环。

### 复杂度

时间复杂度：`O(n^2)`

空间复杂度：`O(1)`

### 稳定性

稳定

---

## 插入排序

将左侧序列看成一个有序序列，每次将一个数字插入该有序序列。插入时，从有序序列最右侧开始比较，若比较的数较大，后移一位。

![插入排序](/assets/images/插入排序.gif)

### 复杂度

时间复杂度：`O(n^2)`

空间复杂度：`O(1)`

### 稳定性

稳定

---

## 选择排序

每次循环选取一个最小的数字交换至前面的有序序列中。

![选择排序](/assets/images/选择排序.gif)

### 复杂度

时间复杂度：`O(n^2)`

空间复杂度：`O(1)`

### 稳定性

不稳定

---

## 快速排序

选取一个基准值，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据以及基准值都要小，再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列。

> 注意：最坏情况下递归调用栈层级过高，可能会引起爆栈。

下面是对序列 `6、1、2、7、9、3、4、5、10、8` 排序的过程：

![快速排序1](/assets/images/快速排序.jpg)
![快速排序2](/assets/images/快速排序.gif)

### 复杂度

时间复杂度：平均 `O(nlogn)`，最坏情况 `O(n^2)`（每次都将数据分割成 1 个与剩下的全部）

空间复杂度：`O(logn)`（递归调用消耗）

### 稳定性

不稳定

---

## 归并排序

采用分治法，将数组从中点进行分割，分为左、右两个数组，再递归分割左、右数组，直到数组长度小于 2，将子数组段间有序地进行归并，最后得到完全有序的序列。

![归并排序](/assets/images/归并排序.gif)

### 复杂度

时间复杂度：`O(nlogn)`

空间复杂度：`O(n)`

### 稳定性

稳定

---

## 堆排序

创建一个大顶堆，大顶堆的堆顶一定是最大的元素，交换堆顶元素与最后一个元素，让剩余的元素继续调整为大顶堆，重复此过程，直到排序完成。

### 复杂度

时间复杂度：`O(nlogn)`

空间复杂度：`O(1)`

### 稳定性

不稳定
